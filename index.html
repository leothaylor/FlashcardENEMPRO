<script>
  // #################################################
  // 0) UTIL
  // #################################################
  const LS_KEY = "flashcard_pro_enem_v2";
  const generateSimpleId = (prefix) => prefix + "-" + Math.random().toString(36).slice(2, 9) + "-" + Date.now();

  const safeJSONParse = (str, fallback) => {
    try { return JSON.parse(str); } catch { return fallback; }
  };

  const saveState = (state) => localStorage.setItem(LS_KEY, JSON.stringify(state));
  const loadState = () => safeJSONParse(localStorage.getItem(LS_KEY), null);

  const $ = (id) => document.getElementById(id);

  const normalizeSubject = (qText) => {
    // tenta achar "(InglÃªs)" "(Espanhol)" etc no cabeÃ§alho da questÃ£o
    const m = qText.match(/\((Ingl[eÃª]s|Espanhol|Franc[eÃª]s)\)/i);
    if (m) {
      const s = m[1].toLowerCase();
      if (s.includes("ing")) return "InglÃªs";
      if (s.includes("esp")) return "Espanhol";
      if (s.includes("fra")) return "FrancÃªs";
      return m[1];
    }
    // fallback: considera Linguagens/PortuguÃªs
    return "Linguagens/PortuguÃªs";
  };

  const stripAnswerPrefix = (ans) => ans.replace(/^Gabarito:\s*/i, "").trim();

  // #################################################
  // 1) DADOS INICIAIS â€” VOCÃŠ JÃ TEM ENEM_2020_D1 ACIMA
  // #################################################
  // Esperado: const ENEM_2020_D1 = [ {id, question, answer}, ... ];

  // #################################################
  // 2) ESTADO GLOBAL
  // #################################################
  let state = null;

  let currentDeckId = null;
  let currentCardIndex = 0;
  let isFlipped = false;
  let reviewMode = false; // se true: sÃ³ difÃ­ceis
  let sessionOrder = [];  // lista de ids na ordem atual de estudo

  // #################################################
  // 3) MODELO DE DADOS NO localStorage
  // #################################################
  const makeFreshState = () => ({
    decks: {},          // { deckId: { id, name, cards: [ {id, question, answer} ] } }
    deckOrder: [],      // [deckId, ...]
    difficultByDeck: {},// { deckId: Set(ids) -> armazenado como array no state }
    stats: {
      totalReviewed: 0,
      byDeck: {}        // { deckId: { reviewed, correct, incorrect } }
    }
  });

  const ensureDeckStats = (deckId) => {
    if (!state.stats.byDeck[deckId]) {
      state.stats.byDeck[deckId] = { reviewed: 0, correct: 0, incorrect: 0 };
    }
  };

  const getDifficultSet = (deckId) => {
    const arr = state.difficultByDeck[deckId] || [];
    return new Set(arr);
  };

  const setDifficultSet = (deckId, setObj) => {
    state.difficultByDeck[deckId] = Array.from(setObj);
  };

  // #################################################
  // 4) BOOTSTRAP: instala o ENEM 2020 D1 na primeira vez
  // #################################################
  const bootstrapIfNeeded = () => {
    state = loadState();
    if (!state) state = makeFreshState();

    // Se nÃ£o tiver deck nenhum, cria decks a partir do ENEM_2020_D1
    if (!state.deckOrder || state.deckOrder.length === 0) {
      const buckets = {}; // subject -> cards[]
      for (const c of (typeof ENEM_2020_D1 !== "undefined" ? ENEM_2020_D1 : [])) {
        const subj = normalizeSubject(c.question);
        if (!buckets[subj]) buckets[subj] = [];
        buckets[subj].push({
          id: c.id || generateSimpleId("card"),
          question: c.question,
          answer: c.answer
        });
      }

      const createdDeckIds = [];

      const subjects = Object.keys(buckets);
      subjects.sort((a, b) => a.localeCompare(b, "pt-BR"));

      for (const subj of subjects) {
        const deckId = generateSimpleId("deck");
        state.decks[deckId] = {
          id: deckId,
          name: `ENEM 2020 D1 â€” ${subj}`,
          cards: buckets[subj]
        };
        state.deckOrder.push(deckId);
        createdDeckIds.push(deckId);

        state.difficultByDeck[deckId] = [];
        ensureDeckStats(deckId);
      }

      saveState(state);
    }
  };

  // #################################################
  // 5) UI: popula seletor e carrega deck
  // #################################################
  const populateDeckSelector = () => {
    const sel = $("deck-selector");
    sel.innerHTML = "";

    for (const deckId of state.deckOrder) {
      const opt = document.createElement("option");
      opt.value = deckId;
      opt.textContent = state.decks[deckId]?.name || "Deck";
      sel.appendChild(opt);
    }

    // mantÃ©m seleÃ§Ã£o
    if (!currentDeckId) currentDeckId = state.deckOrder[0] || null;
    sel.value = currentDeckId;
  };

  const buildSessionOrder = () => {
    const deck = state.decks[currentDeckId];
    if (!deck) { sessionOrder = []; return; }

    const cards = deck.cards || [];
    if (!reviewMode) {
      sessionOrder = cards.map(c => c.id);
      return;
    }
    const diff = getDifficultSet(currentDeckId);
    sessionOrder = cards.filter(c => diff.has(c.id)).map(c => c.id);
  };

  const getCurrentCard = () => {
    const deck = state.decks[currentDeckId];
    if (!deck) return null;
    const id = sessionOrder[currentCardIndex];
    return (deck.cards || []).find(c => c.id === id) || null;
  };

  const updateHeader = () => {
    const deck = state.decks[currentDeckId];
    $("deck-title").textContent = deck ? deck.name : "";
  };

  const updateCounter = () => {
    const total = sessionOrder.length;
    const idx = total ? (currentCardIndex + 1) : 0;
    $("card-counter").textContent = `${idx} / ${total}`;

    $("prev-btn").disabled = currentCardIndex <= 0;
    $("next-btn").disabled = currentCardIndex >= total - 1;
  };

  const updateProgress = () => {
    const total = sessionOrder.length;
    const idx = total ? (currentCardIndex + 1) : 0;
    const pct = total ? Math.round((idx / total) * 100) : 0;

    $("progress-container").setAttribute("aria-valuenow", String(pct));
    $("progress-bar").style.width = `${pct}%`;
    $("progress-text").textContent = total
      ? `Progresso no deck: ${idx} de ${total} cards (${pct}%)`
      : `Sem cards para mostrar neste modo.`;
  };

  const updateDifficultyIcon = () => {
    const card = getCurrentCard();
    const icon = $("difficulty-icon");
    if (!card) {
      icon.classList.remove("text-yellow-400");
      icon.classList.add("text-gray-400");
      return;
    }
    const diff = getDifficultSet(currentDeckId);
    if (diff.has(card.id)) {
      icon.classList.add("text-yellow-400");
      icon.classList.remove("text-gray-400");
    } else {
      icon.classList.remove("text-yellow-400");
      icon.classList.add("text-gray-400");
    }
  };

  const setFlipped = (flip) => {
    isFlipped = flip;
    const inner = $("card-inner");
    if (flip) inner.classList.add("flipped");
    else inner.classList.remove("flipped");

    // mostra botÃµes de feedback sÃ³ no verso
    $("feedback-controls").classList.toggle("hidden", !flip);
  };

  const renderCard = () => {
    const card = getCurrentCard();

    if (!card) {
      $("card-question").textContent = "Nenhum card disponÃ­vel neste modo.\n\nDica: desative 'Revisar DifÃ­ceis' ou marque alguns cards como â­ difÃ­cil.";
      $("card-answer").textContent = "â€”";
      setFlipped(false);
      updateCounter();
      updateProgress();
      updateDifficultyIcon();
      updateReviewButton();
      return;
    }

    $("card-question").textContent = card.question;
    $("card-answer").textContent = stripAnswerPrefix(card.answer);

    setFlipped(false);
    updateCounter();
    updateProgress();
    updateDifficultyIcon();
    updateReviewButton();
  };

  const loadDeck = () => {
    currentDeckId = $("deck-selector").value;
    currentCardIndex = 0;
    reviewMode = false; // reset por padrÃ£o ao trocar de deck
    buildSessionOrder();
    updateHeader();
    renderCard();
  };

  // #################################################
  // 6) AÃ‡Ã•ES: navegar / flip / shuffle / restart
  // #################################################
  const flipCard = () => {
    const card = getCurrentCard();
    if (!card) return;
    setFlipped(!isFlipped);
  };

  const nextCard = () => {
    if (currentCardIndex < sessionOrder.length - 1) {
      currentCardIndex++;
      renderCard();
    }
  };

  const prevCard = () => {
    if (currentCardIndex > 0) {
      currentCardIndex--;
      renderCard();
    }
  };

  const shuffleDeck = () => {
    // embaralha apenas a ordem da sessÃ£o
    for (let i = sessionOrder.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [sessionOrder[i], sessionOrder[j]] = [sessionOrder[j], sessionOrder[i]];
    }
    currentCardIndex = 0;
    renderCard();
  };

  const restartDeck = () => {
    currentCardIndex = 0;
    renderCard();
  };

  // #################################################
  // 7) MARCAÃ‡Ã•ES: difÃ­cil / acertei / errei
  // #################################################
  const markCardDifficult = () => {
    const card = getCurrentCard();
    if (!card) return;

    const setObj = getDifficultSet(currentDeckId);
    if (setObj.has(card.id)) setObj.delete(card.id);
    else setObj.add(card.id);

    setDifficultSet(currentDeckId, setObj);
    saveState(state);

    updateDifficultyIcon();
    updateReviewButton();
    updateStatsModalUI();
  };

  const markCorrect = () => {
    const card = getCurrentCard();
    if (!card) return;

    state.stats.totalReviewed++;
    ensureDeckStats(currentDeckId);
    state.stats.byDeck[currentDeckId].reviewed++;
    state.stats.byDeck[currentDeckId].correct++;
    saveState(state);

    setFlipped(false);
    nextCard();
    updateStatsModalUI();
  };

  const markIncorrect = () => {
    const card = getCurrentCard();
    if (!card) return;

    state.stats.totalReviewed++;
    ensureDeckStats(currentDeckId);
    state.stats.byDeck[currentDeckId].reviewed++;
    state.stats.byDeck[currentDeckId].incorrect++;
    saveState(state);

    setFlipped(false);
    nextCard();
    updateStatsModalUI();
  };

  // #################################################
  // 8) REVIEW MODE (difÃ­ceis)
  // #################################################
  const updateReviewButton = () => {
    const diffCount = (state.difficultByDeck[currentDeckId] || []).length;
    const btn = $("review-mode-btn");
    btn.textContent = reviewMode ? `âœ… Revisando DifÃ­ceis (${diffCount})` : `â­ Revisar DifÃ­ceis (${diffCount})`;
    btn.classList.toggle("bg-red-600", !reviewMode);
    btn.classList.toggle("bg-green-700", reviewMode);
  };

  const toggleReviewMode = () => {
    reviewMode = !reviewMode;
    currentCardIndex = 0;
    buildSessionOrder();
    renderCard();
  };

  // #################################################
  // 9) MODAL: GERENCIAR DECKS / CARDS
  // #################################################
  let managingDeckId = null;

  const openManageModal = () => {
    $("manage-modal").classList.remove("hidden");
    $("manage-modal").classList.add("flex");
    renderDeckList();
    selectDeckForManagement(currentDeckId);
  };

  const closeManageModal = () => {
    $("manage-modal").classList.add("hidden");
    $("manage-modal").classList.remove("flex");
    resetCardEditor();
  };

  const renderDeckList = () => {
    const wrap = $("deck-list");
    wrap.innerHTML = "";

    for (const deckId of state.deckOrder) {
      const d = state.decks[deckId];
      const row = document.createElement("div");
      row.className = "flex items-center justify-between bg-gray-900 border border-gray-700 rounded-lg px-3 py-2";

      const left = document.createElement("button");
      left.className = "text-left flex-grow";
      left.innerHTML = `<div class="font-semibold text-white">${d.name}</div><div class="text-xs text-gray-400">${(d.cards||[]).length} cards</div>`;
      left.onclick = () => selectDeckForManagement(deckId);

      const del = document.createElement("button");
      del.className = "text-red-300 hover:text-red-200 text-sm font-semibold px-2 py-1";
      del.textContent = "Excluir";
      del.onclick = () => deleteDeck(deckId);

      row.appendChild(left);
      row.appendChild(del);
      wrap.appendChild(row);
    }
  };

  const createDeck = () => {
    const name = $("new-deck-name").value.trim();
    if (!name) return;

    const deckId = generateSimpleId("deck");
    state.decks[deckId] = { id: deckId, name, cards: [] };
    state.deckOrder.push(deckId);
    state.difficultByDeck[deckId] = [];
    ensureDeckStats(deckId);

    $("new-deck-name").value = "";
    saveState(state);

    populateDeckSelector();
    renderDeckList();
    selectDeckForManagement(deckId);
  };

  const deleteDeck = (deckId) => {
    if (state.deckOrder.length <= 1) {
      alert("VocÃª precisa manter pelo menos 1 deck.");
      return;
    }
    if (!confirm("Excluir este deck? (cards serÃ£o perdidos)")) return;

    delete state.decks[deckId];
    delete state.difficultByDeck[deckId];
    delete state.stats.byDeck[deckId];

    state.deckOrder = state.deckOrder.filter(id => id !== deckId);

    // se deletou o deck atual, troca
    if (currentDeckId === deckId) currentDeckId = state.deckOrder[0];

    saveState(state);

    populateDeckSelector();
    buildSessionOrder();
    updateHeader();
    renderCard();

    renderDeckList();
    selectDeckForManagement(currentDeckId);
  };

  const selectDeckForManagement = (deckId) => {
    managingDeckId = deckId;
    const d = state.decks[deckId];
    $("card-management-title").textContent = `Cards do Deck: ${d ? d.name : "(Nenhum Selecionado)"}`;
    $("add-card-btn").classList.toggle("hidden", !d);
    renderCardList();
  };

  const openCardEditor = () => {
    $("card-editor-form").classList.remove("hidden");
    $("card-id-editor").value = "";
    $("card-question-editor").value = "";
    $("card-answer-editor").value = "";
  };

  const resetCardEditor = () => {
    $("card-editor-form").classList.add("hidden");
    $("card-id-editor").value = "";
    $("card-question-editor").value = "";
    $("card-answer-editor").value = "";
  };

  const saveCard = () => {
    const deck = state.decks[managingDeckId];
    if (!deck) return;

    const id = $("card-id-editor").value || generateSimpleId("card");
    const q = $("card-question-editor").value.trim();
    const a = $("card-answer-editor").value.trim();
    if (!q || !a) return;

    const idx = (deck.cards || []).findIndex(c => c.id === id);
    if (idx >= 0) deck.cards[idx] = { id, question: q, answer: a };
    else deck.cards.push({ id, question: q, answer: a });

    saveState(state);
    renderDeckList();
    renderCardList();
    resetCardEditor();

    // se salvou no deck atual, recarrega sessÃ£o
    if (managingDeckId === currentDeckId) {
      buildSessionOrder();
      renderCard();
    }
  };

  const editCard = (cardId) => {
    const deck = state.decks[managingDeckId];
    if (!deck) return;
    const c = (deck.cards || []).find(x => x.id === cardId);
    if (!c) return;

    $("card-editor-form").classList.remove("hidden");
    $("card-id-editor").value = c.id;
    $("card-question-editor").value = c.question;
    $("card-answer-editor").value = c.answer;
  };

  const deleteCard = (cardId) => {
    const deck = state.decks[managingDeckId];
    if (!deck) return;
    if (!confirm("Excluir este card?")) return;

    deck.cards = (deck.cards || []).filter(c => c.id !== cardId);

    // remove dos difÃ­ceis se necessÃ¡rio
    const diff = getDifficultSet(managingDeckId);
    diff.delete(cardId);
    setDifficultSet(managingDeckId, diff);

    saveState(state);
    renderDeckList();
    renderCardList();

    if (managingDeckId === currentDeckId) {
      buildSessionOrder();
      currentCardIndex = Math.min(currentCardIndex, Math.max(0, sessionOrder.length - 1));
      renderCard();
    }
  };

  const renderCardList = () => {
    const deck = state.decks[managingDeckId];
    const wrap = $("card-list");
    wrap.innerHTML = "";

    if (!deck) return;

    for (const c of (deck.cards || [])) {
      const row = document.createElement("div");
      row.className = "flex items-center justify-between bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 gap-2";

      const left = document.createElement("button");
      left.className = "text-left flex-grow";
      left.innerHTML = `<div class="font-semibold text-white truncate">${c.question.split("\n")[0].slice(0, 90)}</div><div class="text-xs text-gray-400 truncate">${stripAnswerPrefix(c.answer).slice(0, 110)}</div>`;
      left.onclick = () => editCard(c.id);

      const del = document.createElement("button");
      del.className = "text-red-300 hover:text-red-200 text-sm font-semibold px-2 py-1";
      del.textContent = "Excluir";
      del.onclick = () => deleteCard(c.id);

      row.appendChild(left);
      row.appendChild(del);
      wrap.appendChild(row);
    }
  };

  // #################################################
  // 10) MODAL: STATS + EXPORT PNG
  // #################################################
  const openStatsModal = () => {
    updateStatsModalUI();
    $("stats-modal").classList.remove("hidden");
    $("stats-modal").classList.add("flex");
  };

  const closeStatsModal = () => {
    $("stats-modal").classList.add("hidden");
    $("stats-modal").classList.remove("flex");
  };

  const updateStatsModalUI = () => {
    $("total-reviewed-stats").textContent = String(state.stats.totalReviewed || 0);

    const diffCount = (state.difficultByDeck[currentDeckId] || []).length;
    $("total-difficult-stats").textContent = String(diffCount);

    const ul = $("deck-stats-list");
    ul.innerHTML = "";

    for (const deckId of state.deckOrder) {
      ensureDeckStats(deckId);
      const d = state.decks[deckId];
      const s = state.stats.byDeck[deckId];
      const li = document.createElement("li");
      li.textContent = `${d.name}: revisados ${s.reviewed} | ðŸŸ¢ ${s.correct} | ðŸ”´ ${s.incorrect}`;
      ul.appendChild(li);
    }
  };

  const exportStatsPNG = async () => {
    const node = $("stats-capture");
    const canvas = await html2canvas(node, { backgroundColor: null, scale: 2 });
    const link = document.createElement("a");
    link.download = "estatisticas-flashcard-pro-enem.png";
    link.href = canvas.toDataURL("image/png");
    link.click();
  };

  const resetStats = () => {
    if (!confirm("Resetar estatÃ­sticas?")) return;
    state.stats.totalReviewed = 0;
    state.stats.byDeck = {};
    for (const deckId of state.deckOrder) ensureDeckStats(deckId);
    saveState(state);
    updateStatsModalUI();
  };

  // #################################################
  // 11) TECLADO / ACESSIBILIDADE
  // #################################################
  const onKeyDown = (e) => {
    if (e.code === "Space") {
      e.preventDefault();
      flipCard();
    }
    if (e.code === "ArrowRight") nextCard();
    if (e.code === "ArrowLeft") prevCard();
  };

  // #################################################
  // 12) EVENTOS GLOBAIS (expÃµe funÃ§Ãµes pro HTML)
  // #################################################
  window.openManageModal = openManageModal;
  window.closeManageModal = closeManageModal;
  window.openStatsModal = openStatsModal;
  window.closeStatsModal = closeStatsModal;

  window.createDeck = createDeck;
  window.loadDeck = loadDeck;
  window.openCardEditor = openCardEditor;
  window.saveCard = saveCard;
  window.resetCardEditor = resetCardEditor;

  window.prevCard = prevCard;
  window.nextCard = nextCard;
  window.shuffleDeck = shuffleDeck;
  window.restartDeck = restartDeck;

  window.markCardDifficult = markCardDifficult;
  window.markCorrect = markCorrect;
  window.markIncorrect = markIncorrect;
  window.toggleReviewMode = toggleReviewMode;

  window.exportStatsPNG = exportStatsPNG;
  window.resetStats = resetStats;

  // #################################################
  // 13) INIT
  // #################################################
  document.addEventListener("DOMContentLoaded", () => {
    bootstrapIfNeeded();

    populateDeckSelector();
    buildSessionOrder();
    updateHeader();
    renderCard();
    updateStatsModalUI();

    $("flashcard-container").addEventListener("click", () => flipCard());
    document.addEventListener("keydown", onKeyDown);
  });
</script>
